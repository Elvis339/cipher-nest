use std::sync::Arc;

use curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT;
use curve25519_dalek::scalar::Scalar;
use curve25519_dalek::RistrettoPoint;
use rand_core::OsRng;
use sha2::{Digest, Sha512};
use tokio::try_join;

use crate::ChaumPedersenTrait;

#[derive(Debug, Clone)]
pub struct EccChaumPedersen {
    g: Arc<RistrettoPoint>,
    h: Arc<RistrettoPoint>,
}

impl ChaumPedersenTrait for EccChaumPedersen {
    type Point = RistrettoPoint;
    type Scalar = Scalar;

    /// Given a `secret_scalar`, this function asynchronously calculates
    /// the public keys `y1` and `y2` using elliptic curve multiplication.
    /// The keys are computed as `y1 = g * x` and `y2 = h * x`.
    ///
    /// Arguments:
    /// - `secret_scalar`: Password
    ///
    /// Returns:
    /// - A tuple `(y1, y2)` representing the public keys.
    async fn generate_public_keys(
        &self,
        secret_scalar: Self::Scalar,
    ) -> (Self::Point, Self::Point) {
        let g = self.g.clone();
        let h = self.h.clone();

        // Asynchronously calculate the public keys
        let compute_public_keys = tokio::spawn(async move {
            let y1 = *g * secret_scalar; // Compute y1 = g * x
            let y2 = *h * secret_scalar; // Compute y2 = h * x
            (y1, y2)
        });

        compute_public_keys
            .await
            .expect("failed to compute public keys (y1, y2)")
    }

    /// Generates the prover's commitment values `r1` and `r2` and the challenge `c`.
    /// Here we applied some form of Fiat-Shamir heuristic because prover generates a challenge for himself.
    ///
    /// The function uses the secret random value `k` to calculate `r1` and `r2` using
    /// the group generators `g` and `h`. The challenge `c` is generated by hashing
    /// the compressed forms of `r1` and `r2`.
    ///
    /// Returns a tuple containing the challenge `c` and the secret value `k`.
    async fn prover_commit(&self) -> (Self::Scalar, Option<Self::Scalar>, Option<Self::Scalar>) {
        let mut csprng = OsRng;

        // Generate a random secret value 'k'
        let secret_k = Scalar::random(&mut csprng);

        let generator_g = self.g.clone();
        let generator_h = self.h.clone();

        let (commitment_r1, commitment_r2) = tokio::spawn(async move {
            let r1 = &*generator_g * secret_k;
            let r2 = &*generator_h * secret_k;
            (r1, r2)
        })
        .await
        .expect("Failed to compute prover's commitments");

        let mut challenge_input = Vec::with_capacity(64);
        challenge_input.extend_from_slice(commitment_r1.compress().as_bytes());
        challenge_input.extend_from_slice(commitment_r2.compress().as_bytes());

        // Generate the challenge by hashing r1 and r2
        let challenge_c = Self::hash(challenge_input.as_slice());

        (secret_k, Some(challenge_c), None)
    }

    /// Prover solves the challenge `s = k - c * x`
    /// Where:
    ///     - k: Random number generated by the prover
    ///     - c: Challenge generated by the verifier
    ///     - x: Secret
    fn prover_solve_challenge(
        &self,
        random_k: Self::Scalar,
        challenge: Self::Scalar,
        secret_x: Self::Scalar,
    ) -> Self::Scalar {
        random_k - challenge * secret_x
    }

    async fn verify_proof(
        &self,
        s: Self::Scalar,
        c: Self::Scalar,
        y1: Self::Point,
        y2: Self::Point,
        _r1: Option<Self::Scalar>,
        _r2: Option<Self::Scalar>,
    ) -> bool {
        let verify_closure = |base1: Arc<RistrettoPoint>,
                              exp1: Arc<Scalar>,
                              base2: Arc<RistrettoPoint>,
                              exp2: Arc<Scalar>| {
            tokio::spawn(async move { *base1 * &*exp1 + *base2 * &*exp2 })
        };

        let s = Arc::new(s);
        let c = Arc::new(c);
        let y1 = Arc::new(y1);
        let y2 = Arc::new(y2);

        let t1 = verify_closure(self.g.clone(), s.clone(), y1.clone(), c.clone());
        let t2 = verify_closure(self.h.clone(), s.clone(), y2.clone(), c.clone());

        let (t1, t2) = try_join!(t1, t2).unwrap();

        let t1_compressed = t1.compress();
        let t2_compressed = t2.compress();

        // Now get the bytes
        let t1_bytes = t1_compressed.as_bytes();
        let t2_bytes = t2_compressed.as_bytes();

        // Concatenate
        let mut concatenated = Vec::with_capacity(64);
        concatenated.extend_from_slice(t1_bytes);
        concatenated.extend_from_slice(t2_bytes);

        let computed_challenge = Self::hash(&concatenated);

        // Check if the computed challenge matches the given challenge
        computed_challenge == *c
    }
}

impl EccChaumPedersen {
    /// Generate `H` as `H = [hash(G)]G` where `hash` is `sha512`
    pub fn new() -> Self {
        let h =
            RISTRETTO_BASEPOINT_POINT * Self::hash(RISTRETTO_BASEPOINT_POINT.compress().as_bytes());
        Self {
            g: Arc::new(RISTRETTO_BASEPOINT_POINT),
            h: Arc::new(h),
        }
    }

    /// Hash function to convert byte slices to `Scalar` values
    pub fn hash(input: &[u8]) -> Scalar {
        let mut hasher = Sha512::new();
        hasher.update(input);
        let result = hasher.finalize();
        Scalar::hash_from_bytes::<Sha512>(result.as_slice())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn proof() {
        let password = "my_secret_password";
        let x = EccChaumPedersen::hash(password.as_bytes());

        let ecc_cp = EccChaumPedersen::new();

        let pk = ecc_cp.generate_public_keys(x).await;

        // Prover's commitment
        let (k, c, _) = ecc_cp.prover_commit().await;

        // Prover solves the challenge
        let s = ecc_cp.prover_solve_challenge(k, c.clone().unwrap(), x);

        // serialize and deserialize
        let (str_challenge, str_solution, y1_str, y2_str) = (
            serde_json::to_string(&c.unwrap()).unwrap(),
            serde_json::to_string(&s).unwrap(),
            serde_json::to_string(&pk.0).unwrap(),
            serde_json::to_string(&pk.1).unwrap(),
        );

        let challenge: Scalar = serde_json::from_str(&str_challenge).unwrap();
        let solution: Scalar = serde_json::from_str(&str_solution).unwrap();
        let y1: RistrettoPoint = serde_json::from_str(&y1_str).unwrap();
        let y2: RistrettoPoint = serde_json::from_str(&y2_str).unwrap();

        // Verification
        assert_eq!(
            ecc_cp
                .verify_proof(solution, challenge, y1.clone(), y2.clone(), None, None)
                .await,
            true
        );

        let invalid_pw = "my_password";
        let invalid_x = EccChaumPedersen::hash(invalid_pw.as_bytes());
        let (invalid_y1, invalid_y2) = ecc_cp.generate_public_keys(invalid_x).await;

        assert_eq!(
            ecc_cp
                .verify_proof(s, c.unwrap(), invalid_y1, invalid_y2, None, None)
                .await,
            false,
        );
    }
}
